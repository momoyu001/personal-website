import{_ as s,c as a,o as l,d as n}from"./app.270ddf6f.js";const A=JSON.parse('{"title":"HTML","description":"","frontmatter":{},"headers":[{"level":2,"title":"1、src 和 href 的区别","slug":"_1、src-和-href-的区别","link":"#_1、src-和-href-的区别","children":[{"level":3,"title":"src 和 href 的相同点","slug":"src-和-href-的相同点","link":"#src-和-href-的相同点","children":[]},{"level":3,"title":"src","slug":"src","link":"#src","children":[]},{"level":3,"title":"href","slug":"href","link":"#href","children":[]}]},{"level":2,"title":"2、script 标签","slug":"_2、script-标签","link":"#_2、script-标签","children":[]},{"level":2,"title":"3、HTML5 新增的特性","slug":"_3、html5-新增的特性","link":"#_3、html5-新增的特性","children":[{"level":3,"title":"语义化标签","slug":"语义化标签","link":"#语义化标签","children":[]},{"level":3,"title":"多媒体支持","slug":"多媒体支持","link":"#多媒体支持","children":[]},{"level":3,"title":"canvas 和 svg","slug":"canvas-和-svg","link":"#canvas-和-svg","children":[]},{"level":3,"title":"表单类型属性","slug":"表单类型属性","link":"#表单类型属性","children":[]},{"level":3,"title":"websocket 通信","slug":"websocket-通信","link":"#websocket-通信","children":[]},{"level":3,"title":"拖拽","slug":"拖拽","link":"#拖拽","children":[]},{"level":3,"title":"本地存储","slug":"本地存储","link":"#本地存储","children":[]}]},{"level":2,"title":"4、对 HTML 语义化的理解","slug":"_4、对-html-语义化的理解","link":"#_4、对-html-语义化的理解","children":[]}],"relativePath":"interview/2024interview/html.md"}'),e={name:"interview/2024interview/html.md"},t=n(`<h1 id="html" tabindex="-1">HTML <a class="header-anchor" href="#html" aria-hidden="true">#</a></h1><h2 id="_1、src-和-href-的区别" tabindex="-1">1、src 和 href 的区别 <a class="header-anchor" href="#_1、src-和-href-的区别" aria-hidden="true">#</a></h2><h3 id="src-和-href-的相同点" tabindex="-1">src 和 href 的相同点 <a class="header-anchor" href="#src-和-href-的相同点" aria-hidden="true">#</a></h3><p>都是 HTML 中特定元素的属性，都可以用来引入外部的资源。</p><h3 id="src" tabindex="-1">src <a class="header-anchor" href="#src" aria-hidden="true">#</a></h3><p>当浏览器解析到该元素时，会暂停其他资源的加载和处理，直到该资源加载、编译、执行完成。它会将资源内容嵌入到当前标签所在的位置，将其指向的资源下载应用到文档内。如 js 脚本等。这也是为什么需要将 script 标签放到 body 底部的原因。</p><p>有 src 属性的标签：</p><ul><li>img 标签</li><li>script 标签</li><li>iframe 标签</li><li>video 标签</li><li>audio 标签</li></ul><h3 id="href" tabindex="-1">href <a class="header-anchor" href="#href" aria-hidden="true">#</a></h3><p>超链接，指向外部资源所在的位置，当浏览器识别到它指向的文件时，就会并行下载资源，不会停止对当前文档的处理</p><p>有 href 属性的标签：</p><ul><li>a 标签</li><li>link 标签</li></ul><h2 id="_2、script-标签" tabindex="-1">2、script 标签 <a class="header-anchor" href="#_2、script-标签" aria-hidden="true">#</a></h2><p>作用：引入 js 代码</p><p>引入方式：</p><ul><li>内联：直接将 js 代码写在标签内部</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;script&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&#39;hello&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/script&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li>外置：即通过 src 属性引入外部的 js 文件。可以放置在 html 任意位置。无论是内联还是外置，执行顺序都是从上至下串行。浏览器首次加载 script 期间，还会阻塞 HTML 页面解析。尤其是外部引入的 js 还会经历 网络传输、解析、执行，有时候会导致浏览器页面白屏。</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;html&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  &lt;body&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;script src=&quot;http://www.example.com/example.js&quot;&gt;&lt;/script&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;!-- 只有加载完并执行完 example.js 后，才开始加载 0.js --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;script src=&quot;./js/0.js&quot;&gt;&lt;/script&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  &lt;/body&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/html&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li>动态引入：在 JS 代码里面动态添加 script 标签。</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var myScript = document.createElement(&quot;script&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">myScript.textContent = &#39;alert(&quot;✋&quot;)&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;">document.head.appendChild(myScript);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>注意：通过以下代码创建的 script 标签不会运行</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">document.head.innerHTML += &#39;&lt;script&gt;alert(&quot;✋&quot;)&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>script 标签的 defer 和 async 属性：</p><ul><li>没有任何属性</li></ul><p>在 HTML 的解析过程中，遇到该标签，会暂停解析，先发起网络请求去下载 src 属性指向的 js 文件，然后执行该 js 代码，当代码执行完毕之后再恢复解析 HTML 文档。（有可能会出现白屏问题）</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;script src=&quot;xxx&quot;&gt;&lt;/script&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li>defer 属性</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;script src=&quot;xxx&quot; defer&gt;&lt;/script&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>在 HTML 解析的过程中，遇到该标签，会先去异步下载 js 文件，下载完成之后，若浏览器还未完成 HTML 的解析，也不会阻塞，而是等待 HTML 解析完成之后在执行 js 代码。</p><p>如果存在多个包含 defer 属性的 script 标签，浏览器会按照上下顺序，从上到下按照顺序执行各个 js 文件的代码，不会破坏 JS 脚本之间的依赖关系。</p><ul><li>async 属性</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;script src=&quot;xxx&quot; async&gt;&lt;/script&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>在 HTML 的解析过程中，遇到该标签，会先去异步下载 js 文件，当下载完成之后，若 HTML 文档还未解析完，就会暂停解析，先执行 js 代码，执行完毕之后继续解析。</p><p>async 是不可控的，因为不确定何时会下载完成，若在该 js 代码中操作 DOM，可能会获取不到 DOM 元素。</p><p>如果存在多个包含 async 属性的 script 标签，无法保证各个标签对应的 js 文件执行的顺序。</p><p>总结：</p><table><thead><tr><th>script 标签</th><th>何时开始执行 JS</th><th>JS 执行顺序</th><th>是否阻塞解析 HTML</th></tr></thead><tbody><tr><td><code>&lt;script&gt;</code></td><td>网络请求返回时</td><td>在 HTML 中的顺序</td><td>阻塞</td></tr><tr><td><code>&lt;script async&gt;</code></td><td>网络请求返回时</td><td>网络请求返回的顺序</td><td>可能阻塞，也可能不阻塞</td></tr><tr><td><code>&lt;script defer&gt;</code></td><td>网络请求返回且 HTML 解析完成时</td><td>在 HTML 中的顺序</td><td>不阻塞</td></tr></tbody></table><h2 id="_3、html5-新增的特性" tabindex="-1">3、HTML5 新增的特性 <a class="header-anchor" href="#_3、html5-新增的特性" aria-hidden="true">#</a></h2><p><a href="https://juejin.cn/post/7358361832460173349?searchId=2024071022592824925A195E2C353CF084#heading-34" target="_blank" rel="noreferrer">相关文档连接</a></p><h3 id="语义化标签" tabindex="-1">语义化标签 <a class="header-anchor" href="#语义化标签" aria-hidden="true">#</a></h3><p>语义化标签可以使你的 HTML 结构更具有可读性和可维护性，同时有助于搜索引擎正确解读网络内容，提高网页的排名和可访问性。</p><ul><li>header 定义文档的页眉，通常包含导航链接、网站标志、搜索内容等</li><li>nav 定义导航链接的容器，通常包含网站的主要导航菜单</li><li>main 定义文档的主要内容，通常包含页面的主要内容部分</li><li>article 定义独立的、完整的内容块，如文章等</li><li>section 定义文档中的区段，通常用于组织相关的内容</li><li>aside 定义页面的侧边栏或附加内容，通常包含与页面相关但不是必需的内容，如广告、链接等</li><li>footer 用于定义文档或节的页脚，通常包含版权信息、联系方式、网站地图等</li><li>figure、figcaption 用于组织和标记图片、图表、音频、视频等媒体内容</li><li>details、sunmmary 用于创建可展开的详细信息块，其中 summary 定义了默认可见的摘要</li><li>time 用于标记日期、时间等信息，有助于搜索引擎理解和处理时间相关的内容</li></ul><h3 id="多媒体支持" tabindex="-1">多媒体支持 <a class="header-anchor" href="#多媒体支持" aria-hidden="true">#</a></h3><ul><li>图片：img 标签</li><li>视频：video 标签</li><li>音频：audio 标签</li></ul><h3 id="canvas-和-svg" tabindex="-1">canvas 和 svg <a class="header-anchor" href="#canvas-和-svg" aria-hidden="true">#</a></h3><p><a href="https://juejin.cn/post/7031407945447374861?searchId=2024071121353664A5DEA6581269DA31E9" target="_blank" rel="noreferrer">canvas 参考文档</a></p><h4 id="canvas" tabindex="-1">canvas <a class="header-anchor" href="#canvas" aria-hidden="true">#</a></h4><ul><li>允许通过 js 动态绘制图形；绘制的图形是像素基础的，一旦绘制完成，就无法单独操作其中的元素；</li><li>canvas 通常用于需要实时渲染、动态交互的场景，如图表、游戏、图像处理等；</li><li>提供了一个类似绘图板的 API，可以在其中绘制 2D 图形，如线条、矩形、圆形等；</li><li>canvas 绘图的 API <ul><li>fillRect(x, y, width, height)。绘制一个实心矩形，默认背景颜色为黑色，没有边框</li><li>fillStyle = &quot;颜色值&quot;。填充，配合 fillRect 且在 fillRect 之前使用</li><li>strokeRect(x, y, width, height)。绘制一个空心矩形，默认边框颜色为黑色，边框默认宽:1px</li><li>strokeStyle = &quot;颜色值&quot;。描边(空心)配合 strokeRect()，并在 strokeRect()之前使用</li><li>clearRect(x,y,width,height)。以矩形方式清除指定区域（类似橡皮擦） 放置在要清除的图形位置之后，即绘制一个，清除一下</li><li>globalAlpha = &quot;透明值&quot;。全局设置透明度（0~1）在颜色后设置透明度</li><li>canvas 是按顺序进行画图，后面的图形会将前面的覆盖</li></ul></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;canvas id=&quot;myCanvas&quot; width=&quot;200px&quot; height=&quot;200px&quot;&gt;&lt;/canvas&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;script&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      var myCanvas = document.getElementById(&quot;myCanvas&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">      if (myCanvas.getContext) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // d 只能是小写</span></span>
<span class="line"><span style="color:#A6ACCD;">        const context = myCanvas.getContext(&quot;2d&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        // 填充颜色，需要在 fillRect 之前使用</span></span>
<span class="line"><span style="color:#A6ACCD;">        context.fillStyle = &quot;#ff0000&quot;;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        // fillRect(x, y, width, height) 绘制实心矩形，默认背景色为黑色，没有边框</span></span>
<span class="line"><span style="color:#A6ACCD;">        context.fillRect(0, 0, 20, 20);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        // 描边，需要在 strokeRect 之前使用</span></span>
<span class="line"><span style="color:#A6ACCD;">        context.strokeStyle = &quot;#ff00ff&quot;;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        // strokeRect(x, y, width, height) 空心矩形，默认边框颜色为黑色，默认边框宽度是 1px</span></span>
<span class="line"><span style="color:#A6ACCD;">        context.strokeRect(40, 40, 20, 20);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        context.clearRect(30, 30, 20, 20);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        //  --------------- 渐变 -------------------</span></span>
<span class="line"><span style="color:#A6ACCD;">        var grad = context.createLinearGradient(50, 50, 120, 120);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        // 添加颜色</span></span>
<span class="line"><span style="color:#A6ACCD;">        grad.addColorStop(0, &quot;yellow&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">        grad.addColorStop(0.5, &quot;red&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">        grad.addColorStop(1, &quot;blue&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        // 画矩形</span></span>
<span class="line"><span style="color:#A6ACCD;">        context.fillStyle = grad; // 将渐变加到矩形中</span></span>
<span class="line"><span style="color:#A6ACCD;">        context.fillRect(50, 50, 120, 120);</span></span>
<span class="line"><span style="color:#A6ACCD;">      }</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;/script&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h4 id="svg" tabindex="-1">svg <a class="header-anchor" href="#svg" aria-hidden="true">#</a></h4><p><a href="https://juejin.cn/post/7028958154545168414?searchId=20240714203213CFDFAC143203B0880DF8" target="_blank" rel="noreferrer">SVG 参考文档</a></p><ul><li>SVG 是一种基于 XML 的矢量图形描述语言，可以在 HTML 中以标记形式使用</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li><li>由于 SVG 是 XML 文件，SVG 图像可以用任何文本编辑器创建，但是复杂的图形还是需要使用图形编辑工具</li><li>SVG 的优势 <ul><li>可以被非常多的工具读取和修改</li><li>与 JPEG、GIF 图像比起来，尺寸更小，且可压缩性更强</li><li>是可伸缩的</li><li>可在任何分辨率下被高质量的打印</li><li>可在图像质量不下降的情况下放大</li><li>图像中的文本是可搜索的（适合制作地图）</li><li>是纯粹的 XML</li></ul></li></ul><p>svg 示例：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">&quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  stroke-width=&quot;2&quot; fill=&quot;red&quot; /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/svg&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li>第一行是 XML 的声明</li><li>standalone 属性规定此 SVG 文件是否是独立的，或含有对外部文件的引用，<code>standalone=&quot;no&quot;</code> 意味着 SCG 文件会引用一个外部文件</li><li><code>&lt;svg&gt;&lt;/svg&gt;</code> 是表示 SVG 的代码。相当于开始标签和结束标签，这里是根元素</li><li>width height 属性用于设置 SVG 文档的高度和宽度</li><li>version 定义所使用的 SVG 版本</li><li>xmlns 定义 SVG 的命名空间</li><li><code>&lt;circle /&gt;</code> 用来创建一个圆。cx 和 cy 属性定义圆中心的 x 和 y 坐标。如果忽略这两个属性，那么圆点会被设置为 (0, 0)。r 属性定义圆的半径。</li><li>stroke 和 stroke-width 属性控制如何显示形状的轮廓。我们把圆的轮廓设置为 2px 宽，黑边框。</li><li>fill 属性设置形状内的颜色。我们把填充颜色设置为红色。</li><li>关闭标签的作用是关闭 SVG 元素和文档本身。</li><li>所有的开启标签必须有关闭标签！</li></ul><h3 id="表单类型属性" tabindex="-1">表单类型属性 <a class="header-anchor" href="#表单类型属性" aria-hidden="true">#</a></h3><h4 id="input-标签" tabindex="-1">input 标签 <a class="header-anchor" href="#input-标签" aria-hidden="true">#</a></h4><h5 id="type-属性" tabindex="-1">type 属性 <a class="header-anchor" href="#type-属性" aria-hidden="true">#</a></h5><ul><li>email：H5</li><li>url：H5</li><li>tel：H5</li><li>number：PC &amp; H5</li><li>时间：PC &amp; H5 <ul><li>time</li><li>date</li><li>datetime</li><li>month</li><li>week</li></ul></li><li>color</li><li>range</li><li>search</li></ul><h5 id="表单属性" tabindex="-1">表单属性 <a class="header-anchor" href="#表单属性" aria-hidden="true">#</a></h5><ul><li>autocomplete</li><li>autofocus</li><li>multiple</li><li>required</li></ul><h4 id="链接属性" tabindex="-1">链接属性 <a class="header-anchor" href="#链接属性" aria-hidden="true">#</a></h4><h5 id="link-标签" tabindex="-1">link 标签 <a class="header-anchor" href="#link-标签" aria-hidden="true">#</a></h5><p>用于建立文档与外部资源之间的关系。这些资源可以是样式表，网站图标，字体文件，或者其他网页所需的资源等等</p><ul><li>href：指明外部资源文件的路径，即告诉浏览器外部资源的位置</li><li>hreflang：说明外部资源使用的语言</li><li>media：说明外部资源用于哪种设备</li><li>ref：必填，表明当前文档和外部资源的关系。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/rel" target="_blank" rel="noreferrer">MDN 参考文档</a></li><li>sizes：主要用于 link 中的网页图标大小的控制，只对 <code>ref=&quot;icon&quot;</code> 生效</li><li>type：说明外部资源的 MIME 类型，如 <code>text/css</code>，<code>image/x-icon</code></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 引入样式表</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; type=&quot;text/css&quot; /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 设定网站标题</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 引入字体文件</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Roboto&quot; /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h5 id="base" tabindex="-1">base <a class="header-anchor" href="#base" aria-hidden="true">#</a></h5><p>base 标签，位于 head 标签中，base 标签的 target 属性可以控制整个网页中 a 链接打开新窗口，也可以控制 a 链接跳转的页面</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;"> &lt;head&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;!-- 这里 target 的值表示打开新的浏览器标签页 --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;base href=&#39;https://www.baidu.com/&#39; target=&#39;_blank&#39;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/head&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;body&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  &lt;!-- 这里 a 标签必须要有 href 属性 --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;a href&gt;aaa&lt;/a&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/body&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h4 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-hidden="true">#</a></h4><h5 id="script-新属性" tabindex="-1">script 新属性 <a class="header-anchor" href="#script-新属性" aria-hidden="true">#</a></h5><ul><li><p>defer 属性：异步下载，下载完成且 html 解析完成之后开始执行</p></li><li><p>async 属性：异步下载，下载完成之后就会开始执行，此时 html 可能解析完了，也可能还没有解析完成</p></li></ul><h3 id="websocket-通信" tabindex="-1">websocket 通信 <a class="header-anchor" href="#websocket-通信" aria-hidden="true">#</a></h3><p><a href="https://juejin.cn/post/7020964728386093093?searchId=20240716065825551B9980046A0040345D" target="_blank" rel="noreferrer">参考文档</a></p><p><a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noreferrer">阮一峰 WebSocket 教程</a></p><p>websocket 是一种全双工通信协议（本质上是一种<code>计算机网络应用层的协议</code>，用来弥补 http 协议在持久通信能力上的不足），它允许在 Web 应用程序和服务器之间建立持久性连接，从而实现实时数据交换。websocket 使得客户端和服务器之间只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。与传统的 HTTP 请求响应模式不同，websocket 允许双方同时发送和接收数据，使得在客户端和服务器之间进行实时通信变得更加高效和简单。</p><ul><li>全双工通信：WebSocket 允许客户端和服务器之间的双向通信，而不像传统的 HTTP 请求-响应模式那样需要先发出请求再等待响应。</li><li>持久连接：一旦建立 WebSocket 连接，它将保持打开状态，允许随时发送数据，而不需要在每次通信时都重新建立连接。</li><li>低延迟：由于 WebSocket 建立的是长期持久的连接，因此通信过程中的延迟较低，适合需要实时性要求高的应用场景，如在线游戏、实时聊天等。</li><li>轻量级：WebSocket 协议相对于传统的 HTTP 请求-响应协议来说，通信时的开销较小，因为在连接建立后只需少量的额外开销。</li><li>跨域支持：WebSocket 支持跨域通信，但需要在服务器端进行相应的配置。</li><li>默认端口：80 和 443，握手阶段采用 HTTP 协议</li><li>可以发送文本，也可以发送二进制数据</li><li>协议标识符是<code>ws</code>，如果加密，则为 <code>wss</code>。例如：<code>ws://example.com:80/some/path</code></li></ul><p>应用场景：</p><ul><li>在线游戏</li><li>聊天应用</li><li>股票市场行情</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 简单应用示例</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;script&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">      ws.open = function (evt) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&quot;connection open...&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">        ws.send(&quot;Hello WebSocket!!!&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">      };</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">      ws.onmessage = function (evt) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&quot;received message：&quot;, evt.data);</span></span>
<span class="line"><span style="color:#A6ACCD;">        ws.close();</span></span>
<span class="line"><span style="color:#A6ACCD;">      };</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">      ws.onclose = function (evt) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&quot;Connection closed.&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">      };</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;/script&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="拖拽" tabindex="-1">拖拽 <a class="header-anchor" href="#拖拽" aria-hidden="true">#</a></h3><p><a href="https://juejin.cn/post/6844903513491767303?searchId=202407162014430F71706C5D1360BA5B96" target="_blank" rel="noreferrer">参考文档</a></p><p>总体流程：选中 -&gt; 拖动 -&gt; 释放</p><h4 id="选中" tabindex="-1">选中 <a class="header-anchor" href="#选中" aria-hidden="true">#</a></h4><ul><li>给元素设置 <code>draggable</code> 属性为 <code>true</code></li><li>文本、图片、链接是默认可拖放的，他们的 draggable 属性被默认设置为了 true <ul><li>文本只有被选中的情况下才可以拖放。如果显式的设置 draggable 属性为 true，那么按住鼠标左键之后也可以拖动</li><li>图片和链接按住鼠标左键选中就可以拖放</li></ul></li><li><code>draggable</code> 属性的值 <ul><li>true：可以拖动</li><li>false：禁止拖动</li><li>auto：跟随浏览器定义是否可以拖动</li></ul></li></ul><h4 id="拖动" tabindex="-1">拖动 <a class="header-anchor" href="#拖动" aria-hidden="true">#</a></h4><p>拖动开始 -&gt; 拖动过程中 -&gt; 拖动结束</p><table><thead><tr><th>针对对象</th><th>事件名称</th><th>说明</th></tr></thead><tbody><tr><td>被拖动的元素</td><td>dragstart</td><td>在元素开始被拖拽时触发</td></tr><tr><td>被拖动的元素</td><td>drag</td><td>在元素被拖拽过程中反复触发</td></tr><tr><td>被拖动的元素</td><td>dragend</td><td>在拖动操作完成时触发</td></tr><tr><td>目的地对象</td><td>dragenter</td><td>当被拖动元素进入目的地元素所占据的屏幕空间时触发</td></tr><tr><td>目的地对象</td><td>dragover</td><td>当被拖动元素在目标元素内时触发</td></tr><tr><td>目的地对象</td><td>dragleave</td><td>当被拖动元素没有放下就离开目的地元素时触发</td></tr></tbody></table><p>dragenter 和 dragover 事件的默认行为是拒绝接受任何被拖放的元素。因此，我们必须阻止浏览器这种默认行为。e.preventDefault();</p><h4 id="释放" tabindex="-1">释放 <a class="header-anchor" href="#释放" aria-hidden="true">#</a></h4><p>目的地元素 - drop 事件 - 当被拖放元素在目的地元素里放下时触发，一般需要取消浏览器的默认行为</p><h3 id="本地存储" tabindex="-1">本地存储 <a class="header-anchor" href="#本地存储" aria-hidden="true">#</a></h3><h4 id="localstorage" tabindex="-1">localStorage <a class="header-anchor" href="#localstorage" aria-hidden="true">#</a></h4><h4 id="sessionstorage" tabindex="-1">sessionStorage <a class="header-anchor" href="#sessionstorage" aria-hidden="true">#</a></h4><h2 id="_4、对-html-语义化的理解" tabindex="-1">4、对 HTML 语义化的理解 <a class="header-anchor" href="#_4、对-html-语义化的理解" aria-hidden="true">#</a></h2><ul><li>根据内容选择合适的标签</li><li>方便浏览器爬虫更好的识别内容</li><li>有利于代码的可读性，开发者能够清晰的看出网页的结构</li><li>有利于无障碍阅读</li></ul>`,97),i=[t];function p(o,c,r,d,h,C){return l(),a("div",null,i)}const g=s(e,[["render",p]]);export{A as __pageData,g as default};
