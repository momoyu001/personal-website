import{_ as s,c as a,o as e,d as n}from"./app.3caf6091.js";const m=JSON.parse('{"title":"git基础","description":"","frontmatter":{},"headers":[{"level":2,"title":"git 使用大致流程","slug":"git-使用大致流程","link":"#git-使用大致流程","children":[]},{"level":2,"title":"git命令","slug":"git命令","link":"#git命令","children":[]},{"level":2,"title":"文件重命名","slug":"文件重命名","link":"#文件重命名","children":[]},{"level":2,"title":"git log命令","slug":"git-log命令","link":"#git-log命令","children":[]},{"level":2,"title":"git分支","slug":"git分支","link":"#git分支","children":[]},{"level":2,"title":"gitk","slug":"gitk","link":"#gitk","children":[]},{"level":2,"title":".git文件夹","slug":"git文件夹","link":"#git文件夹","children":[]},{"level":2,"title":"commit tree blob三个对象之间的关系","slug":"commit-tree-blob三个对象之间的关系","link":"#commit-tree-blob三个对象之间的关系","children":[]},{"level":2,"title":"HEAD","slug":"head","link":"#head","children":[]},{"level":2,"title":"git底层的运行流程","slug":"git底层的运行流程","link":"#git底层的运行流程","children":[]},{"level":2,"title":"cat命令","slug":"cat命令","link":"#cat命令","children":[]},{"level":2,"title":"Git的术语","slug":"git的术语","link":"#git的术语","children":[{"level":3,"title":"分离头指针 - dettach head","slug":"分离头指针-dettach-head","link":"#分离头指针-dettach-head","children":[]}]},{"level":2,"title":"tips","slug":"tips","link":"#tips","children":[]},{"level":2,"title":"Git常见场景","slug":"git常见场景","link":"#git常见场景","children":[{"level":3,"title":"删除不需要的分支","slug":"删除不需要的分支","link":"#删除不需要的分支","children":[]},{"level":3,"title":"恢复删除掉的分支","slug":"恢复删除掉的分支","link":"#恢复删除掉的分支","children":[]},{"level":3,"title":"修改最新commit的message","slug":"修改最新commit的message","link":"#修改最新commit的message","children":[]},{"level":3,"title":"修改老旧commit的message","slug":"修改老旧commit的message","link":"#修改老旧commit的message","children":[]},{"level":3,"title":"把多个commit整理成一个","slug":"把多个commit整理成一个","link":"#把多个commit整理成一个","children":[]},{"level":3,"title":"把间隔的commit整理成一个","slug":"把间隔的commit整理成一个","link":"#把间隔的commit整理成一个","children":[]},{"level":3,"title":"怎么比较暂存区和HEAD所含文件的差异","slug":"怎么比较暂存区和head所含文件的差异","link":"#怎么比较暂存区和head所含文件的差异","children":[]},{"level":3,"title":"怎么比较工作区和暂存区所含文件的差异","slug":"怎么比较工作区和暂存区所含文件的差异","link":"#怎么比较工作区和暂存区所含文件的差异","children":[]},{"level":3,"title":"将暂存区恢复成和HEAD一样","slug":"将暂存区恢复成和head一样","link":"#将暂存区恢复成和head一样","children":[]},{"level":3,"title":"将工作区恢复成和暂存区一样（还原工作区的内容，不做修改）","slug":"将工作区恢复成和暂存区一样-还原工作区的内容-不做修改","link":"#将工作区恢复成和暂存区一样-还原工作区的内容-不做修改","children":[]},{"level":3,"title":"取消暂存区部分文件的更改","slug":"取消暂存区部分文件的更改","link":"#取消暂存区部分文件的更改","children":[]},{"level":3,"title":"消除最近的几次提交","slug":"消除最近的几次提交","link":"#消除最近的几次提交","children":[]},{"level":3,"title":"不同commit的指定文件之间的差异","slug":"不同commit的指定文件之间的差异","link":"#不同commit的指定文件之间的差异","children":[]},{"level":3,"title":"删除暂存区的文件","slug":"删除暂存区的文件","link":"#删除暂存区的文件","children":[]},{"level":3,"title":"git stash","slug":"git-stash","link":"#git-stash","children":[]},{"level":3,"title":"Git仓库备份到本地","slug":"git仓库备份到本地","link":"#git仓库备份到本地","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"pull request","slug":"pull-request","link":"#pull-request","children":[]},{"level":2,"title":"merge request","slug":"merge-request","link":"#merge-request","children":[]},{"level":2,"title":"结论","slug":"结论","link":"#结论","children":[]}],"relativePath":"other/git.md"}'),l={name:"other/git.md"},t=n(`<h1 id="git基础" tabindex="-1">git基础 <a class="header-anchor" href="#git基础" aria-hidden="true">#</a></h1><h2 id="git-使用大致流程" tabindex="-1">git 使用大致流程 <a class="header-anchor" href="#git-使用大致流程" aria-hidden="true">#</a></h2><ul><li>git add files 工作目录 -&gt; 暂存区</li><li>git commit 暂存区 -&gt; 版本历史</li></ul><h2 id="git命令" tabindex="-1">git命令 <a class="header-anchor" href="#git命令" aria-hidden="true">#</a></h2><ul><li>git add -u: 将文件的修改 文件的删除,添加到暂存区 (即 操作追踪过的文件)</li><li>git add . : 将文件的修改 文件的新建,添加到暂存区</li><li>git add -A : 将文件的修改 文件的删除 文件的新建,添加到暂存区</li><li>git reset --hard : 将暂存区 \\ 工作目录下的内容都清空掉. 使得工作目录还原到最后一次commit的状态,也就是说.在最后一次commit之后<code>git add git rm</code>的操作以及在工作目录的修改都撤销了</li><li>git diff &lt;commit的hash值&gt; &lt;commit的hash值&gt; : 比较两个commit的差异</li></ul><h2 id="文件重命名" tabindex="-1">文件重命名 <a class="header-anchor" href="#文件重命名" aria-hidden="true">#</a></h2><ul><li>直接修改文件名,git会提示,原文件被删除,有一个新的还没有跟踪过的文件</li><li>将新的文件git add添加到暂存区</li><li>原来的文件<code>git rm &lt;filename&gt;</code>删除</li></ul><p>终极解决方式:</p><p><code>git mv &lt;原文件名&gt; &lt;新的文件名&gt;</code></p><h2 id="git-log命令" tabindex="-1">git log命令 <a class="header-anchor" href="#git-log命令" aria-hidden="true">#</a></h2><ul><li><code>git log --all</code> 查看所有分支的历史</li><li><code>git log --all --graph</code> 查看图形化的log地址</li><li><code>git log --oneline</code> 查看单行的简洁历史</li><li><code>git log --oneline -n4</code> 查看最近的四条简洁历史</li><li><code>git log --oneline --al -n4 --graph</code> 查看所有分支,最近4条单行的图形化历史</li><li><code>git hepl --web log</code> 跳转到git log的帮助文档页面</li></ul><h2 id="git分支" tabindex="-1">git分支 <a class="header-anchor" href="#git分支" aria-hidden="true">#</a></h2><ul><li><code>git branch</code> 查看分支</li><li><code>git branch -v</code> 查看本地分支信息</li><li><code>git checkout -b &lt;分支名&gt; &lt;已有分支的某个commit号,依据此时的分支来创建新的分支&gt;</code> 创建新分支，并切换到新的分支</li><li><code>git branch -r</code> 查看远程分支</li><li><code>git branch &lt;分支名&gt;</code> 创建新的分支</li><li><code>git checkout &lt;分支名&gt;</code> 切换分支</li><li><code>git diff &lt;分支名&gt; &lt;分支名&gt;</code> 对比分支之间的差异</li><li><code>git merge &lt;master1 - 分支名&gt;</code> 将master1分支合并到当前分支</li><li><code>git branch -d &lt;分支名&gt;</code> 删除分支</li></ul><h2 id="gitk" tabindex="-1">gitk <a class="header-anchor" href="#gitk" aria-hidden="true">#</a></h2><p>图形界面工具 - 查看版本历史</p><h2 id="git文件夹" tabindex="-1">.git文件夹 <a class="header-anchor" href="#git文件夹" aria-hidden="true">#</a></h2><ul><li>HEAD: 存储当前分支信息,当前仓库正在工作在哪个分支上，HEAD里面是个引用 <ul><li>refs/heads/temp temp分支</li><li>refs/heads/master master分支</li></ul></li><li>config: 存储当前本地仓库配置的信息，比如用户名邮箱</li><li>refs: 引用，存放各个分支或tag的信息</li><li>objects：对象，有 <code>commit</code> ,<code> tree</code> ,<code> blob</code>等对象</li></ul><h2 id="commit-tree-blob三个对象之间的关系" tabindex="-1">commit tree blob三个对象之间的关系 <a class="header-anchor" href="#commit-tree-blob三个对象之间的关系" aria-hidden="true">#</a></h2><ul><li><p>commit</p><ul><li>一个commit对应一棵树，树里面存储了很多详细信息</li></ul></li><li><p>tree</p><ul><li>树里面也有可能有树，一层层嵌套，最后到叶子节点，叶子节点就是blob - 文件</li></ul></li><li><p>blob</p><ul><li><p>git的文件，跟文件名没有关系，是根据文件的内容的生成的blob</p></li><li><p>就算文件名不同，只要文件内容相同，在git里面就是同一个blob -- 节省了存储空间</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 看commit的内容</span></span>
<span class="line"><span style="color:#A6ACCD;">输入： git cat-file -p e3146ef80824</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：</span></span>
<span class="line"><span style="color:#A6ACCD;">    tree 74df5a60ef8b3ce7542e24e216ac53d3dbbd90d4</span></span>
<span class="line"><span style="color:#A6ACCD;">    parent 0f04ce8bd6b08fa51c87781f19edafa37274c09e</span></span>
<span class="line"><span style="color:#A6ACCD;">    author momoyu001 &lt;lixia1220x@163.com&gt; 1655963464 +0800</span></span>
<span class="line"><span style="color:#A6ACCD;">    committer momoyu001 &lt;lixia1220x@163.com&gt; 1655963464 +0800</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    修改readme</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 看tree的内容</span></span>
<span class="line"><span style="color:#A6ACCD;">输入：git cat-file -p 74df5a60e</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：</span></span>
<span class="line"><span style="color:#A6ACCD;">    100644 blob ac060a6ee0a290981d83072597ce97594caaf2e5    README.md</span></span>
<span class="line"><span style="color:#A6ACCD;">    040000 tree d920f9932cd1d84256cbf604fccf54e3f5a2a822    images</span></span>
<span class="line"><span style="color:#A6ACCD;">    100644 blob 049bff1d5f07d1fe2a71c851561be81ef284019e    index.html</span></span>
<span class="line"><span style="color:#A6ACCD;">    040000 tree 7d35ef1b137d107abbe907c637c72f7fe79e97b7    js</span></span>
<span class="line"><span style="color:#A6ACCD;">    040000 tree f627fc3a5190ffe116ecb147dd99f19db1a15faa    styles</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li></ul></li></ul><p>练习：新建的git仓库，有且仅有一个commit，仅仅包含/doc/readme，请问内含多少个tree，多少个blob?</p><p><strong>没有文件的文件夹，git是不进行版本管理的。因为git要对文件进行版本管理，所以没有必要对空目录生成对象。基于这一点，readme文件的全路径是这样的<code>[仓库跟目录]/doc/readme</code>。那么tree的数量与全路径中<code>/</code>的数量一致</strong></p><p><strong>演示一下：</strong></p><p>​ 这里演示的时候，readme文件中没有写入任何内容，git创建了一个内容为空的blob对象。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git init test_git_objects</span></span>
<span class="line"><span style="color:#A6ACCD;">cd test_git_objects</span></span>
<span class="line"><span style="color:#A6ACCD;">新建doc文件夹</span></span>
<span class="line"><span style="color:#A6ACCD;">git status</span></span>
<span class="line"><span style="color:#A6ACCD;">	nothing to commit</span></span>
<span class="line"><span style="color:#A6ACCD;">新家readme文件</span></span>
<span class="line"><span style="color:#A6ACCD;">git status</span></span>
<span class="line"><span style="color:#A6ACCD;">	doc/需要跟踪</span></span>
<span class="line"><span style="color:#A6ACCD;">git add doc</span></span>
<span class="line"><span style="color:#A6ACCD;">git commit -m &quot;新的文件&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">find ./.git/objects/ -type f // 查看objects下面有没有东西</span></span>
<span class="line"><span style="color:#A6ACCD;">	./.git/objects/55/8e9aacb7eee6b66f8247b58527ec69e182b382 // 经测试： tree doc</span></span>
<span class="line"><span style="color:#A6ACCD;">    ./.git/objects/5a/45cb108aacdb65fae9b6b32cc2c367c694775c // 经测试： commit</span></span>
<span class="line"><span style="color:#A6ACCD;">    ./.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391 // 经测试： blob 内容为空</span></span>
<span class="line"><span style="color:#A6ACCD;">    ./.git/objects/e8/0ad49ace82167de62e498622d70377d913c79e // 经测试： tree 100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    readme</span></span>
<span class="line"><span style="color:#A6ACCD;">// 可以依次查看下各个对象，是什么对象，有什么内容</span></span>
<span class="line"><span style="color:#A6ACCD;">git cat-file -t 558e9aacb7 // 查看类型</span></span>
<span class="line"><span style="color:#A6ACCD;">git cat-file -p 558e9aacb7 // 查看内容</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li>commit对象 <ul><li>tree <ul><li>tree对象 <ul><li>tree: doc <ul><li>tree对象 <ul><li>blob: readme <ul><li>blob对象 <ul><li>hello, world</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>parent</li><li>author</li><li>...</li></ul></li></ul><h2 id="head" tabindex="-1">HEAD <a class="header-anchor" href="#head" aria-hidden="true">#</a></h2><p>查看的命令：<code>cat .git/HEAD</code> ---&gt; <code>refs/head/分支名称</code></p><p>​ \`\`\`</p><p>​ 输入：cat .git/HEAD</p><p>​ 输出：ref: refs/heads/fix_readme</p><p>​ \`\`\`</p><ul><li><p>指代新分支的最后一次提交</p></li><li><p>可以不跟分支挂钩，处于分离头指针的状态下，没有挂钩分支，指代到某一个具体的commit</p></li><li><p>切换分支时，HEAD会跟着变，指向新的分支</p></li><li><p>比较两次commit的差异时，可以使用HEAD指代</p><ul><li><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight has-diff"><code><span class="line"><span style="color:#A6ACCD;">git diff &lt;hash值&gt; &lt;hash值&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">git diff HEAD HEAD^1 // 比较HEAD指向的commi 和 它的父级commit之间的差异</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">^ 表示父commit，两个箭头表示父级的父级。后面的数字表示第几个父亲。当一个commit有多个父commit时，可以通过在^后面跟上一个数字来表示第几个父commit。连续的^符号，依次沿着父commit进行定位，直到某个祖先commit。</span></span>
<span class="line"><span style="color:#A6ACCD;">~&lt;n&gt;	相当于	连续n个^</span></span>
<span class="line"><span style="color:#A6ACCD;">^1		相当于		~1</span></span>
<span class="line"><span style="color:#A6ACCD;">^^1		相当于		~2</span></span>
<span class="line"><span style="color:#A6ACCD;">^2		表示 第二个父节点</span></span>
<span class="line"><span style="color:#A6ACCD;">~2		表示 父节点的父节点</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li></ul></li><li><p>指向分支，分支里面的内容是什么？<strong>最终还是指向了一个commit</strong></p><ul><li><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">cat .git/refs/heads/fix_readme</span></span>
<span class="line"><span style="color:#A6ACCD;">	7508aaa54ce504f4ac05779f5c4479b2c26e0e6a</span></span>
<span class="line"><span style="color:#A6ACCD;">git cat-file -t 7508aa</span></span>
<span class="line"><span style="color:#A6ACCD;">	commit</span></span>
<span class="line"><span style="color:#A6ACCD;">git cat-file -p 7508aa</span></span>
<span class="line"><span style="color:#A6ACCD;">	tree fcc5c104ad481bfc2ae29301c9b502ab5cac7c24</span></span>
<span class="line"><span style="color:#A6ACCD;">    parent 0f04ce8bd6b08fa51c87781f19edafa37274c09e</span></span>
<span class="line"><span style="color:#A6ACCD;">    author momoyu001 &lt;lixia1220x@163.com&gt; 1655975881 +0800</span></span>
<span class="line"><span style="color:#A6ACCD;">    committer momoyu001 &lt;lixia1220x@163.com&gt; 1655975881 +0800</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    BackgoundColor modified</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li></ul></li></ul><h2 id="git底层的运行流程" tabindex="-1">git底层的运行流程 <a class="header-anchor" href="#git底层的运行流程" aria-hidden="true">#</a></h2><p>​ 当我们添加或者修改了文件并且add到stage area之后，首先会根据文件内容创建不同的blob，当进行提交之后，马上创建一个tree组件，把需要的blob组件添加进去，之后再封装到一个commit组件中完成本次的提交。</p><p>​ 在将来进行reset的时候，可以直接使用使用<code>git reset --hard &lt;XXXXX&gt;</code>可以恢复到某个特定的版本，在reset之后，git会根据这个commit组件的id快速找到tree组件，然后根据tree组件找到blob组件，之后对仓库进行还原，整个过程都是以哈希和二进制的方式进行的，所以git执行效率非常高。</p><h2 id="cat命令" tabindex="-1">cat命令 <a class="header-anchor" href="#cat命令" aria-hidden="true">#</a></h2><p>cat命令主要用于查看文件的内容，创建文件，文件合并，追加文件内容等功能。</p><p>.git目录下：</p><p>​ cat HEAD: 查看HEAD文件的内容</p><ul><li>git-cat-file: 显示版本库对象的内容、类型及大小信息</li><li>git-cat-file -t &lt;hash值&gt; ： 显示版本库对象的类型</li><li>git-cat-file -p &lt;hash值&gt;： 显示对象的内容</li></ul><h2 id="git的术语" tabindex="-1">Git的术语 <a class="header-anchor" href="#git的术语" aria-hidden="true">#</a></h2><h3 id="分离头指针-dettach-head" tabindex="-1">分离头指针 - dettach head <a class="header-anchor" href="#分离头指针-dettach-head" aria-hidden="true">#</a></h3><p>场景：</p><p>git checkout &lt;直接跟上某一个commit的hash值&gt;。执行之后，会提示</p><p><code>you are in &#39;detached head&#39; state。</code></p><p>git log之后，commit后面的<code>（HEAD）</code>没有指向任何一个分支，着就处于分离头指针的状态</p><p>本质上：</p><p>就是说我们工作在一个没有分支的状态下。我们的修改没有跟任何一个分支相关联。</p><p>这种状态下，我们所作的修改，在切换分支之后，可能都会被git当作垃圾丢掉。</p><p>适用场景：</p><p>当要做出的某些修改，最后可能也不需要保留，使用分离头指针，可以很方便就将这部分代码清除掉。</p><h2 id="tips" tabindex="-1">tips <a class="header-anchor" href="#tips" aria-hidden="true">#</a></h2><p>命令中,什么时候用 <code>--</code> 什么时候用 <code>-</code> 呢?</p><p>详情参数使用<code>--</code>, 简化参数(如单字母)使用<code>-</code></p><h2 id="git常见场景" tabindex="-1">Git常见场景 <a class="header-anchor" href="#git常见场景" aria-hidden="true">#</a></h2><h3 id="删除不需要的分支" tabindex="-1">删除不需要的分支 <a class="header-anchor" href="#删除不需要的分支" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git branch -d &lt;分支名称&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>若git提示：该分支还没有被完全merge，可控的情况下可以使用下面的命令</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git branch -D &lt;分支名称&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>-d必须时已经将分支完全合并到其上游分支或者HEAD中，否则不能成功。HEAD的场景</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 1、从master分支，创建一个test分支</span></span>
<span class="line"><span style="color:#A6ACCD;">git checkout -b test master</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 2、在test分支上修改东西并提交</span></span>
<span class="line"><span style="color:#A6ACCD;">git add .</span></span>
<span class="line"><span style="color:#A6ACCD;">git commit -m &quot;修改test分支的内容&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 3、切换到master分支，此时的HEAD指向的是master分支</span></span>
<span class="line"><span style="color:#A6ACCD;">git checkout master</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 4、此时test分支比master多了一个commit,尝试删除test分支， 控制台提示 The branch &#39;test&#39; is not fully merge</span></span>
<span class="line"><span style="color:#A6ACCD;">git branch -d test</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 5、使用分离头指针, test分支的那个commit id； 结果可以看到HEAD 和 test 在同一个commit上</span></span>
<span class="line"><span style="color:#A6ACCD;">git checkout bfc138f8d16</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 6、此时在执行删除的命令，成功删除分支</span></span>
<span class="line"><span style="color:#A6ACCD;">git branch -d test</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 或者第4步之后，直接使用 git branch -D test 强制删除</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="恢复删除掉的分支" tabindex="-1">恢复删除掉的分支 <a class="header-anchor" href="#恢复删除掉的分支" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git reflog &lt;subcommond&gt; &lt;potions&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>reflog是一个本地结构，它记录了HEAD和分支引用在过去指向的位置。reflog信息没法与其他人共享 ，每个人都有自己特有的reflog。重要的一点是，它不是永久有效的，有个可配置的过期时间，过期信息自动删除。</p><p>恢复被删除的分支：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 展示所有的reflog，找到被删掉的分支最后一次commit的id</span></span>
<span class="line"><span style="color:#A6ACCD;">git  reflog show</span></span>
<span class="line"><span style="color:#A6ACCD;">// 根据id重新生成分支</span></span>
<span class="line"><span style="color:#A6ACCD;">git checkout -b test bfc138f</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="修改最新commit的message" tabindex="-1">修改最新commit的message <a class="header-anchor" href="#修改最新commit的message" aria-hidden="true">#</a></h3><p>对最近一次commit的message做出修改。</p><p>--amend命令不止是修改message信息，而是替代了上一次commit</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git commit --amend</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>执行命令之后，会进入vim编辑器，修改内容之后，按<code>ESC</code>退出编辑状态，<code>:wq!</code>保存并退出界面</p><h3 id="修改老旧commit的message" tabindex="-1">修改老旧commit的message <a class="header-anchor" href="#修改老旧commit的message" aria-hidden="true">#</a></h3><p>当代码还没有推到远程分支的时候，可以使用rebase（变基）来修改，有远程分支之后，就不能轻易的使用rebase了。</p><p>团队中公用的分支，🈲用rebase，因为会破坏历史commit信息。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git rebase --- 变基</span></span>
<span class="line"><span style="color:#A6ACCD;">git rebase -i &lt;commit 的 id&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>变基的基，选择要被变的这个commit的父亲</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 找到我们要修改的commit的父亲的commit id</span></span>
<span class="line"><span style="color:#A6ACCD;">git rebase -i &lt;commit id&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 进入到了一个交互式的界面，界面上有说明各个关键字的含义，我们要修改message的话，要选用reword use commit, but edit the commit messsage。不需要修改的commit保持不动</span></span>
<span class="line"><span style="color:#A6ACCD;">// 这个策略编写完成之后，保存并退出</span></span>
<span class="line"><span style="color:#A6ACCD;">reword &lt;commit id&gt; &lt;原来的message&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 退出之后会进入另一个界面我们在这个界面修改message信息</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 保存并退出之后，控制太提示 successfully rebases and updated refs/heads/master</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>如果要修改第一次提交的message，使用 :root 来作为父亲</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git rebase -i --root</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><code>git rebase -i</code> 操作会分离头指针。是因为：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git rebase工作的过程中就是使用了分离头指针。rebase意味着基于新base的commit来变更部分commit。（新的base的commit没有基于任何一个分支）。它处理的时候，把HEAD指向base的commit，此时如果该commit没有对应的branch，就处于分离头指针的状态，然后重新一个个生成新的commit，当rebase创建完最后一个commit之后，结束头指针分离状态，Git让变完基的分支名指向HEAD。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>message也是commit的一个属性，是确定commit的hash的一个因子。当修改了一个commit之后，因为commit有个parent属性，parent的内容变化了之后，本身也会变化，也就是说，被修改的commit之后的commit也会跟着改变了（hash值）。</p><p>commit中包含了message、作者、创建时间、父亲等信息，这些信息都和hash值的生成有关，改变了之后，hash值也可能会改变。</p><h3 id="把多个commit整理成一个" tabindex="-1">把多个commit整理成一个 <a class="header-anchor" href="#把多个commit整理成一个" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git rebase -i &lt;开始的commit id&gt; &lt;结束的commit id&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>在执行这个命令时，如果没有指定结束commit id，那么结束commit id默认为当前分支最新的commit，那么rebase结束之后，会自动更新当前分支指向的commit，如果指定了结束commit，而且结束commit不是当前分支最新的commit，那么rebase结束之后，会生成一个游离的head，而且当前分支指向的commit不会更新。</p><p>进入交互界面之后 ，选择<code>squash &lt;commit&gt; = use commit, but meld into previous commit</code>合并到前面的commit中。</p><p>保存退出之后进入新的交互界面，写一下合并commit的原因。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;"># This is a combination of 3 commits</span></span>
<span class="line"><span style="color:#A6ACCD;">// 这里写一下合并commit的原因</span></span>
<span class="line"><span style="color:#A6ACCD;">......</span></span>
<span class="line"><span style="color:#A6ACCD;"># This is the 1st commit message</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="把间隔的commit整理成一个" tabindex="-1">把间隔的commit整理成一个 <a class="header-anchor" href="#把间隔的commit整理成一个" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git rebase -i &lt;开始的commit id&gt; &lt;结束的commit id&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>我们的第一个commit是 <code>add readme</code>，要将第一个commit和后面一个readme的commit合并，一个小技巧，在交互界面上自己手动加上<code>pick &lt;第一个commit的id&gt;</code>（或者使用<code>git rebase -i --root</code>）； 我们可以根据需要自己调整commit的位置，达到合并的效果。</p><p>修改完成保存退出。</p><p>可能出现没有及时进入下一个交互界面。</p><p>使用<code>git rebase --continue</code>,重新进入一个交互界面</p><p>写 一下合并commit的原因，保存退出，即完成了合并。</p><p>git rebase之后若产生了冲突，解决冲突之后，先<code>git add .</code>，然后在<code>git rebase -i --continue</code>。</p><p>git rebase 第一步配置了策略之后，后续不想再继续rebase了，使用<code>git rebase --abort</code></p><h3 id="怎么比较暂存区和head所含文件的差异" tabindex="-1">怎么比较暂存区和HEAD所含文件的差异 <a class="header-anchor" href="#怎么比较暂存区和head所含文件的差异" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight has-diff"><code><span class="line"><span style="color:#A6ACCD;">// cached 和 staged都指向暂存区</span></span>
<span class="line"><span style="color:#A6ACCD;">git diff --cached</span></span>
<span class="line"><span style="color:#A6ACCD;">git diff --staged</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>HEAD指向了最近的一次commit，其实就是暂存区和最近一次commit的差异比较。</p><p>git add 之后，内容进入暂存区。</p><p>后面加上文件名，比较特定的文件。</p><p>后面不加文件名，比较所有的差异。</p><h3 id="怎么比较工作区和暂存区所含文件的差异" tabindex="-1">怎么比较工作区和暂存区所含文件的差异 <a class="header-anchor" href="#怎么比较工作区和暂存区所含文件的差异" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight has-diff"><code><span class="line"><span style="color:#A6ACCD;">// 比较工作区所有文件和暂存区的差异</span></span>
<span class="line"><span style="color:#A6ACCD;">git diff</span></span>
<span class="line"><span style="color:#A6ACCD;">// 比较工作区某一个文件和暂存区的差异</span></span>
<span class="line"><span style="color:#A6ACCD;">git diff -- &lt;具体的文件名&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><code>git diff</code>默认情况下比较的是<code>暂存区</code>和<code>工作区</code>之间的区别</p><h3 id="将暂存区恢复成和head一样" tabindex="-1">将暂存区恢复成和HEAD一样 <a class="header-anchor" href="#将暂存区恢复成和head一样" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 将所有文件恢复成和HEAD一样</span></span>
<span class="line"><span style="color:#A6ACCD;">git reset HEAD</span></span>
<span class="line"><span style="color:#A6ACCD;">// 将某个文件恢复成和HEAD一样</span></span>
<span class="line"><span style="color:#A6ACCD;">git reset HEAD &lt;文件名&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="将工作区恢复成和暂存区一样-还原工作区的内容-不做修改" tabindex="-1">将工作区恢复成和暂存区一样（还原工作区的内容，不做修改） <a class="header-anchor" href="#将工作区恢复成和暂存区一样-还原工作区的内容-不做修改" aria-hidden="true">#</a></h3><p>tips:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">如果想变更 工作区 的内容，使用 git checkout</span></span>
<span class="line"><span style="color:#A6ACCD;">如果想变更 暂存区 的内容，使用 git reset</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">关于命令的变更：git 2.23之后的变更</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">git switch替换git checkout的切换分支功能 git switch &lt;分支名&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">git restore替换git checkout的对工作区进行恢复的功能 git restore &lt;文件名&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">恢复某一个具体的文件</span></span>
<span class="line"><span style="color:#A6ACCD;">git checkout -- &lt;文件名&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="取消暂存区部分文件的更改" tabindex="-1">取消暂存区部分文件的更改 <a class="header-anchor" href="#取消暂存区部分文件的更改" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git  reset HEAD -- &lt;文件名&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="消除最近的几次提交" tabindex="-1">消除最近的几次提交 <a class="header-anchor" href="#消除最近的几次提交" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git reset --hard &lt;commit id&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>修改HEAD指向这个commit id，这个commit id之后的几次提交都会被丢弃，暂存区和工作区也恢复成了你指定的那个commit的内容</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">修改了工作区：恢复 --- git checkout &lt;文件名&gt;   git restore &lt;文件名&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">add后：恢复 --- git reset HEAD</span></span>
<span class="line"><span style="color:#A6ACCD;">commit后：恢复 --- git reset --hard &lt;commit id&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">C1&lt;--C2&lt;--C3&lt;--C4, Cn全部是commit，且C1是C2的父亲，依次类推，</span></span>
<span class="line"><span style="color:#A6ACCD;">如果C3有问题，你想撤销C3的修改，由此生成C5，历史树变成C1&lt;--C2&lt;--C3&lt;--C4--C5，执行git revert C3,就会生成C5，且C5就是清除C3的变更。</span></span>
<span class="line"><span style="color:#A6ACCD;">如果无需保留C3和C4，指向让分支回退到C2，那么执行git reset --hard C2,使用了 --hard ，它会把工作区和暂存区都回退到C2。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="不同commit的指定文件之间的差异" tabindex="-1">不同commit的指定文件之间的差异 <a class="header-anchor" href="#不同commit的指定文件之间的差异" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight has-diff"><code><span class="line"><span style="color:#A6ACCD;">git diff &lt;分支名1&gt;  &lt;分支名2&gt; -- &lt;文件名&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">git diff &lt;commit-id-1&gt; &lt;commit-id-2&gt; &lt;文件名&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="删除暂存区的文件" tabindex="-1">删除暂存区的文件 <a class="header-anchor" href="#删除暂存区的文件" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git rm &lt;文件名&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>直接再工作区和暂存区中删除某个将来不需要提交到commit的文件时，使用命令<code>git rm &lt;filename&gt;</code></p><p><code>rm &lt;filename&gt;</code> 删除工作区的文件</p><p><code>git rm &lt;filename&gt;</code> 删除工作区的文件（可直接执行这一命令来删除）</p><h3 id="git-stash" tabindex="-1">git stash <a class="header-anchor" href="#git-stash" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">  // 将工作区的内容存起来，可以去开发其他的功能，完了之后再恢复</span></span>
<span class="line"><span style="color:#A6ACCD;">  git stash</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 查看现在stash栈中的内容，相当于一个栈，可执行pop apply的方法</span></span>
<span class="line"><span style="color:#A6ACCD;">  git stash list</span></span>
<span class="line"><span style="color:#A6ACCD;">    stash@{0}: ...</span></span>
<span class="line"><span style="color:#A6ACCD;">    stash@{1}: ...</span></span>
<span class="line"><span style="color:#A6ACCD;">    stash@{2}: ...</span></span>
<span class="line"><span style="color:#A6ACCD;">    stash@{3}: ...</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 恢复之前的内容，但是stash栈中，这条信息还在，不会被删除</span></span>
<span class="line"><span style="color:#A6ACCD;">  git stash apply</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 恢复之前的内容，同时stash栈中的着条信息被删除</span></span>
<span class="line"><span style="color:#A6ACCD;">  git stash pop</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git stash list</span></span>
<span class="line"><span style="color:#A6ACCD;">	stash@{0}: ...</span></span>
<span class="line"><span style="color:#A6ACCD;">	stash@{1}: ...</span></span>
<span class="line"><span style="color:#A6ACCD;">	stash@{2}: ...</span></span>
<span class="line"><span style="color:#A6ACCD;">	stash@{3}: ...</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">这些是序号，序号中，数字大的表示是较早的stash，git stash pop的时候，可以添加具体的序号，不加序号的情况下，默认为 stash@{0}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git stash pop stash@{2}</span></span>
<span class="line"><span style="color:#A6ACCD;">git stash pop === git stash pop stash@{0}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// stash 时，添加相应的说明信息</span></span>
<span class="line"><span style="color:#A6ACCD;">git stash save &lt;message&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="git仓库备份到本地" tabindex="-1">Git仓库备份到本地 <a class="header-anchor" href="#git仓库备份到本地" aria-hidden="true">#</a></h3><p>1、准备一个备份文件夹，原文件夹中执行<code>pwd</code>查看路径</p><p>2、在备份文件中 执行</p><p>​ <code>--bare : 备份时不带工作区, 克隆一个裸仓库</code>,</p><p>​ 哑协议方式：没有进度的展示</p><p>​ <code>git clone --bare D:\\front-space\\git_learning &lt;重命名文件夹&gt;</code></p><p>​ 智能协议方式：有进度的展示</p><p>​ <code>git clone --bare file:///D/front-space/git_learning &lt;重命名文件夹&gt;</code></p><p>和远端仓库发生关联: （可以用本地备份的仓库，模拟远端仓库）<strong>git remote</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git remote add &lt;本地模拟的远端仓库的地址&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">// git remote add ya D:\\front-space\\git_learning_bac</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 本地发生一些改动，比如新建了分支，推送远端</span></span>
<span class="line"><span style="color:#A6ACCD;">git push ya</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 可能会有提示</span></span>
<span class="line"><span style="color:#A6ACCD;">git push --set-upstream ya momoyu001</span></span>
<span class="line"><span style="color:#A6ACCD;">git push --set-upstrea &lt;远端仓库名称&gt; &lt;分支名称&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 查看当前仓库的远端</span></span>
<span class="line"><span style="color:#A6ACCD;">git remote -v</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h3><p>删除不需要的分支<code>git branch -d &lt;分支名&gt;</code>,<code>git branch -D &lt;分支名&gt;</code></p><p>恢复删除的分支<code>git reflog</code>获取分支的最新commitid，<code>git checkout -b &lt;分支名&gt; &lt;commit id&gt;</code></p><p>修改最新的commit<code>git commit --amend</code></p><p>修改老旧的commit<code>git rebase -i &lt;父亲的commit id&gt;</code>，<code>pick 改为 reword ( r )</code></p><p>合并连续的commit<code>git rebase -i &lt;父亲的commit id (开始的commit id)&gt; &lt;结束的commit id 可不写&gt;</code> 保留较老的<code>pick</code>，其他要合并的使用 <code>squash (s)</code> s表示合并到上一个commit</p><p>合并不连续的commit<code>git rebase -i &lt;父亲的commit id&gt;</code>，保留较老的<code>pick</code>，根据需要移动其他的commit，并修改为 <code>squash (s)</code></p><p>比较暂存区和最新一次commit（HEAD）的差异<code>git diff --cached</code></p><p>比较暂存区和工作区的文件差异<code>git diff</code>，<code>git diff -- &lt;文件名&gt;</code></p><p>比较工作区和HEAD（最新一次commit）的差异<code>git diff HEAD</code></p><p>将暂存区恢复成和HEAD一样<code>git reset HEAD</code>，<code>git reset HEAD &lt;文件名&gt;</code></p><p>工作区恢复成和暂存区一样<code>git checkout -- &lt;文件名&gt;</code>，<code>git restore &lt;文件名&gt;</code></p><p>取消暂存区部分的修改<code>git reset HEAD &lt;文件名&gt;</code></p><p>消除最近的几次提交<code>git reset --hard &lt;commit id&gt;</code></p><p><strong>cherry-pick</strong>:</p><p>将一个分支上的某个commit合并到另一个分支。</p><p>例如：test 分支上有commit-id-1。</p><p>切换到master分支。</p><p>执行<code>git cherry-pick &lt;commit-id-1&gt;</code>。</p><p>执行<code>git push</code>推送到远端。</p><p><em>master分支上的commit-id与test分支上的commit-id并不相同，即只是 将test分支上的修改拷贝一份过来。</em></p><p><code>cherry-pick</code>后可以跟上多个commit-id。</p><p><strong>git rebase</strong>:</p><p>1、合并分支</p><p>2、合并commit</p><p><strong>git revert</strong>:</p><h1 id="git与github的简单同步" tabindex="-1">Git与Github的简单同步 <a class="header-anchor" href="#git与github的简单同步" aria-hidden="true">#</a></h1><p>添加远端：<code>git remote add &lt;自己的命名(例如：github)&gt; &lt;远端地址&gt;</code></p><p>push代码：<code>git push github --all</code>，<code>git push github &lt;某一个具体的分支名&gt;</code></p><p>--all ： 所有的分支，只提交某一分支的时候，为具体的分支名</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 拉取远端最新的代码</span></span>
<span class="line"><span style="color:#A6ACCD;">git fetch &lt;远端&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 先拉取远端最新的代码，然后把远端和本地，关联的分支做一个merge</span></span>
<span class="line"><span style="color:#A6ACCD;">git pull</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>当本地仓库的远端不止一个的时候，需要在git fetch 或者 git pull 或者 git push后面加上对应的远端名称</p><p><em>注意</em>：</p><p><code>git remote add</code>，是在本地已经是git仓库的情况下使用，若是先创建了远程仓库，git clone到本地之后，再开始写代码，不需要手动进行本地仓库和远端的连接。</p><p><strong>fast forward</strong>:</p><p>举个例子：本地分支往远端分支push的时候，如果远端分支不是本地分支的祖先，那么它们就不是<code>fast forward</code>，反之它们就是<code>fast forward</code>。</p><p>远程分支如果不是本地分支的<code>fast forward</code>，push的时候就会报错提示。</p><p>当出现了不是<code>fast forward</code>的情况，两种解决方式：<code>git merge</code>，<code>git rebase</code></p><p>​ <em>git merge</em>:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">可以先查看文档</span></span>
<span class="line"><span style="color:#A6ACCD;">git merge -h</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">合并远端的master分支（前面的操作，把远端命名为了github）</span></span>
<span class="line"><span style="color:#A6ACCD;">git merge --allow-unrelated-gistories github/master</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>​ <em>git rebase</em>:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">先把远端的分支fetch到本地</span></span>
<span class="line"><span style="color:#A6ACCD;">git fetch</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">git pull --rebase</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>SSH</strong>:</p><h1 id="git多人单分支集成协作的常用场景" tabindex="-1">Git多人单分支集成协作的常用场景 <a class="header-anchor" href="#git多人单分支集成协作的常用场景" aria-hidden="true">#</a></h1><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git push</span></span>
<span class="line"><span style="color:#A6ACCD;">切换分支之前指定远端的分支，那么在提交的时候，直接git push是不会有问题的，默认是origin远端分支，可以不写后面的分支</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">远端新建了分支，本地还没有这个分支，需要先更新本地的分支</span></span>
<span class="line"><span style="color:#A6ACCD;">git fetch &lt;自己定义的远端的名称&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git branch -av</span></span>
<span class="line"><span style="color:#A6ACCD;">可以看到各个分支上，commit的最新情况，比如[ahead 1, behind 1]表示，本地的分支，比远端分支多一个新的commit，少了一个其他人提交的commit，出现这种情况，可以使用 git merge合并对应的分支</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git pull</span></span>
<span class="line"><span style="color:#A6ACCD;">先将远端的分支拉取下来，然后和本地对应的分支做一个合并。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git pull === git fetch + git merge</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">git merge / git rebase</span></span>
<span class="line"><span style="color:#A6ACCD;">git merge	不会改变两个分支的已有版本历史，只会把两个分支合并后创建出一个新的commit出来</span></span>
<span class="line"><span style="color:#A6ACCD;">git rebase	假设当前在 A 分支，要基于B分支做rebase，那么，先找到A和B最近的公共祖先C1，从C1到A之间所有的commit，都基于B重新生成新的commit，rebase通常会改变某个分支的历史。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">一人修改了文件内容，一人修改了文件名，不会产生冲突的根本原因是，git存放blob文件时，是以文件内容来区分的，并不以文件名来区分。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">两个人同时改了一个文件的名称，会有冲突。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><em>注意</em>：</p><p>我们本地是无法在远端分支上直接做出变更的，只能基于远端分支建立本地分支后，才能commit。</p><h1 id="pulll-request-和-merge-request" tabindex="-1">pulll request 和 merge request <a class="header-anchor" href="#pulll-request-和-merge-request" aria-hidden="true">#</a></h1><h2 id="pull-request" tabindex="-1">pull request <a class="header-anchor" href="#pull-request" aria-hidden="true">#</a></h2><p>即<strong>PR</strong>。</p><p>github上面，当自己想给其他的仓库贡献代码时，先 把别人的仓库<code>fork</code>一下到自己的仓库，自己用<code>fork</code>之后的仓库来修改并提交代码，开发完成之后给仓库owner提交<code>PR</code>合并请求，请求鄙人把自己的代码拉回去。</p><h2 id="merge-request" tabindex="-1">merge request <a class="header-anchor" href="#merge-request" aria-hidden="true">#</a></h2><p>即<strong>MR</strong>。</p><p>gitlab上面，一般是公司的私有库，一个团队维护一个仓库，通常大家会新建自己的分支，开发完成之后，把代码合并到主分支上面。</p><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-hidden="true">#</a></h2><p>pull request 和 merge request其实差不多，只是在不同平台上的叫法有差异。</p><h1 id="github认证" tabindex="-1">github认证 <a class="header-anchor" href="#github认证" aria-hidden="true">#</a></h1><p>github修改了认证方式，现在不再支持用户名&amp;密码的方式认证，改成了个人token的方式，我们在执行git add, git commit, git push等操作的时候，会弹出一个弹窗要求输入用户名和密码，密码就是我们个人token，如何生成个人token，可以查看 <a href="https://blog.csdn.net/weixin_44341110/article/details/120510816" target="_blank" rel="noreferrer">Git使用个人访问令牌提交代码到仓库_落丶寞的博客-CSDN博客_git 个人令牌</a>。</p><p>若没有弹出登录的弹窗，使用 <code>git credential-manager uninstall</code>命令，执行命令之后，再进行操作就会弹出。</p>`,208),p=[t];function i(c,o,r,d,g,C){return e(),a("div",null,p)}const A=s(l,[["render",i]]);export{m as __pageData,A as default};
