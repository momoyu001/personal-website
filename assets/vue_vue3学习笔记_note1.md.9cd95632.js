import{_ as s,c as a,o as e,d as l}from"./app.fc8d6d98.js";const y=JSON.parse('{"title":"前端框架","description":"","frontmatter":{},"headers":[{"level":2,"title":"MVVM框架简介","slug":"mvvm框架简介","link":"#mvvm框架简介","children":[]},{"level":2,"title":"Vue和React的对比：","slug":"vue和react的对比","link":"#vue和react的对比","children":[]},{"level":2,"title":"vue3需不需要react的fiber？？？","slug":"vue3需不需要react的fiber","link":"#vue3需不需要react的fiber","children":[]},{"level":2,"title":"vue2 的核心模块","slug":"vue2-的核心模块","link":"#vue2-的核心模块","children":[]},{"level":2,"title":"历史遗留问题","slug":"历史遗留问题","link":"#历史遗留问题","children":[]},{"level":2,"title":"Vue3新特性","slug":"vue3新特性","link":"#vue3新特性","children":[{"level":3,"title":"RFC机制","slug":"rfc机制","link":"#rfc机制","children":[]},{"level":3,"title":"响应式系统","slug":"响应式系统","link":"#响应式系统","children":[]},{"level":3,"title":"自定义渲染器","slug":"自定义渲染器","link":"#自定义渲染器","children":[]},{"level":3,"title":"全部模块使用TypeScript重构","slug":"全部模块使用typescript重构","link":"#全部模块使用typescript重构","children":[]},{"level":3,"title":"Composition API","slug":"composition-api","link":"#composition-api","children":[]},{"level":3,"title":"新的组件","slug":"新的组件","link":"#新的组件","children":[]},{"level":3,"title":"新一代工程化工具Vite","slug":"新一代工程化工具vite","link":"#新一代工程化工具vite","children":[]}]},{"level":2,"title":"不兼容的写法","slug":"不兼容的写法","link":"#不兼容的写法","children":[]},{"level":2,"title":"自动化工具的升级","slug":"自动化工具的升级","link":"#自动化工具的升级","children":[]}],"relativePath":"vue/vue3学习笔记/note1.md"}'),n={name:"vue/vue3学习笔记/note1.md"},p=l(`<h1 id="前端框架" tabindex="-1">前端框架 <a class="header-anchor" href="#前端框架" aria-hidden="true">#</a></h1><h2 id="mvvm框架简介" tabindex="-1">MVVM框架简介 <a class="header-anchor" href="#mvvm框架简介" aria-hidden="true">#</a></h2><p>前端MVVM框架实现的目标：<strong>数据驱动页面</strong>。但每个MVVM框架对于数据驱动页面的实现，基本都是不一样的。 - 即数据更新之后，我们怎么通知页面进行更新。</p><ul><li>Angular：<strong>脏检查</strong><ul><li>每次用户交互时，就去检查一次数据是否变化，有变化就去更新DOM</li></ul></li><li>Vue1：<strong>响应式</strong><ul><li>初始化的时候，<code>Watcher</code> 监听了数据的每个属性，这样数据发生变化时，就能精确知道数据的哪个<code>key</code>改变了，去针对性的修改DOM。</li></ul></li><li>Vue2、Vue3：<strong>响应式 + 虚拟DOM</strong><ul><li>组件间使用响应式：组件间的变化，响应式系统来通知更新；组件内使用虚拟DOM去更新页面。</li><li>引入虚拟DOM，给vue带来了跨端的能力。就是我们可以使用JSON描述vue的项目，可以基于JSON在小程序渲染、在App渲染，这是vue1没有的能力。</li><li><code>Vue3把虚拟DOM的静态标记做到了极致，让静态的部分越过了虚拟DOM的计算，真正做到了按需更新，提高性能</code>。</li></ul></li><li>React：<strong>虚拟DOM</strong><ul><li>用一个JavaScript对象来描述整个DOM树，通过对虚拟DOM的计算，知道变化的数据，进行精确的修改。</li><li>数据有变化时，生成一份新的虚拟DOM，与之前的虚拟DOM进行计算，算出需要修改的DOM，再去页面进行操作。</li><li>虚拟DOM的diff逻辑，可以尽可能的减少对DOM的操作。 <ul><li>引入了fiber架构。时间切片，来解决卡顿的问题</li></ul></li></ul></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">    // 虚拟DOM...</span></span>
<span class="line"><span style="color:#A6ACCD;">    {</span></span>
<span class="line"><span style="color:#A6ACCD;">        tag: &quot;div&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">        attrs: {</span></span>
<span class="line"><span style="color:#A6ACCD;">            id: &quot;app&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">        },</span></span>
<span class="line"><span style="color:#A6ACCD;">        children: [</span></span>
<span class="line"><span style="color:#A6ACCD;">            {</span></span>
<span class="line"><span style="color:#A6ACCD;">            tag: &quot;p&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">                attrs: { className: &quot;item&quot; },</span></span>
<span class="line"><span style="color:#A6ACCD;">                children: [&quot;Item1&quot;]</span></span>
<span class="line"><span style="color:#A6ACCD;">            },</span></span>
<span class="line"><span style="color:#A6ACCD;">            {</span></span>
<span class="line"><span style="color:#A6ACCD;">            tag: &quot;div&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">                attrs: { className: &quot;item&quot; },</span></span>
<span class="line"><span style="color:#A6ACCD;">                children: [&quot;Item2&quot;]</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        ]</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="vue和react的对比" tabindex="-1">Vue和React的对比： <a class="header-anchor" href="#vue和react的对比" aria-hidden="true">#</a></h2><ul><li>通知页面更新： <ul><li><code>Vue</code>：当数据发生变化后：框架会主动告知哪些数据发生了变化。</li><li><code>React</code>：当数据发生变化后：只能通过新老数据的计算diff来得知数据的变化。</li></ul></li><li>性能问题： <ul><li><code>Vue</code>：项目大了之后，每一个数据都有一个Watcher，<code>Watcher</code>多了会严重影响性能</li><li><code>React</code>：项目大了之后，虚拟DOM树过于庞大，diff计算可能会造成卡顿。</li></ul></li><li>解决性能问题的方案： <ul><li><code>Vue</code>：Vue2中引入虚拟DOM来解决性能的问题。响应式数据主动推送数据变化，虚拟DOM是被动计算数据的Diff。组件级别划分两种技术。</li><li><code>React</code>：引入了操作系统的时间切片概念，引入了<code>fiber</code>架构。把整个虚拟DOM微观化，变成链表，然后再利用浏览器的空闲时间计算Diff。巧妙利用空闲时间计算，解决了卡顿的问题。树形结构的Diff很难中断（属性结构的diff用的是递归，递归本身就是难以中断的），链表结构的Diff可以随时中断和继续。</li></ul></li></ul><h2 id="vue3需不需要react的fiber" tabindex="-1">vue3需不需要react的fiber？？？ <a class="header-anchor" href="#vue3需不需要react的fiber" aria-hidden="true">#</a></h2><p>不需要。时间切片解决的问题，在vue3里面基本碰不到。</p><ul><li>Vue2、3的虚拟DOM控制在组件级别，只在组件内部使用虚拟DOM，组件之间使用响应式，这就让vue的虚拟DOM不会过于庞大</li><li>Vue3虚拟DOM的静态标记和自动缓存功能 ，让静态的节点和属性可以直接绕过Diff逻辑，也就大大减少了DOM的Diff事件</li><li>时间切片也会带来额外的系统复杂性。</li></ul><h1 id="初探vue3新特性" tabindex="-1">初探Vue3新特性 <a class="header-anchor" href="#初探vue3新特性" aria-hidden="true">#</a></h1><p><a href="https://github.com/vuejs/vue-next" target="_blank" rel="noreferrer">vue github</a></p><h2 id="vue2-的核心模块" tabindex="-1">vue2 的核心模块 <a class="header-anchor" href="#vue2-的核心模块" aria-hidden="true">#</a></h2><ul><li>响应式驱动</li><li>内置虚拟DOM</li><li>组件化</li><li>用在浏览器开发</li><li>运行时，把以上模块很好的管理起来</li></ul><h2 id="历史遗留问题" tabindex="-1">历史遗留问题 <a class="header-anchor" href="#历史遗留问题" aria-hidden="true">#</a></h2><ul><li>Vue2使用Flow.js来做类型校验，但目前Flow.js已经停止维护</li><li>Vue2内部运行时，是直接执行浏览器API。但这样就会在Vue2的跨端方案中带来问题</li><li>Vue2响应式并不是真正意义上的代理，而是基于Object.defineProperty（）实现的。这个API并不是代理，而是对某个属性进行拦截，比如 删除数据 就无法监听</li><li>Option API在代码较多时不好维护</li><li>生命周期 <ul><li>vue3中，只有createApp,然后立刻调用mount()才可以进入生命周期。</li><li>vue2中，new Vue，但是没有给el，或者没有$mount挂载组件，这是组件的beforeCreate和created依旧会执行。</li></ul></li></ul><h2 id="vue3新特性" tabindex="-1">Vue3新特性 <a class="header-anchor" href="#vue3新特性" aria-hidden="true">#</a></h2><p><strong>响应式系统</strong>、<strong>Composition API组合语法</strong>、<strong>新的组件</strong>、<strong>Vite</strong>、<strong>自定义渲染器 - 开发跨端应用</strong>、<strong>RFC机制 - 对Vue源码做贡献</strong></p><p>Vue2中可以在main.js中定义一些Vue.$xxx的全局变量，然后再JS里面使用，Vue3中取消了这种写法。</p><h3 id="rfc机制" tabindex="-1">RFC机制 <a class="header-anchor" href="#rfc机制" aria-hidden="true">#</a></h3><p>与代码无关，是Vue团队的工作方式。 <a href="https://github.com/vuejs/rfcs" target="_blank" rel="noreferrer">RFC链接戳这里！</a></p><h3 id="响应式系统" tabindex="-1">响应式系统 <a class="header-anchor" href="#响应式系统" aria-hidden="true">#</a></h3><p>Vue2：Object.defineProperty() - 拦截某个属性。对于不存在的属性是没有办法进行拦截的，所以Vue2中所有数据都要在data里面声明。</p><p>Vue3：Proxy - 真正的代理。拦截的是整个obj，具体obj有什么属性，Proxy并不关心。</p><h3 id="自定义渲染器" tabindex="-1">自定义渲染器 <a class="header-anchor" href="#自定义渲染器" aria-hidden="true">#</a></h3><p>Vue2：内部所有模块都是揉在一起的</p><p>Vue3：拆包。响应式、编译、运行时全部独立了。</p><ul><li>Vue2的响应式只服务于Vue，Vue3的响应式就和Vue解耦了，甚至可以再react、node中使用响应式。</li><li>渲染逻辑的拆分：<code>平台无关的渲染逻辑</code>、<code>浏览器渲染的API</code></li></ul><h3 id="全部模块使用typescript重构" tabindex="-1">全部模块使用TypeScript重构 <a class="header-anchor" href="#全部模块使用typescript重构" aria-hidden="true">#</a></h3><p>类型系统，对代码进行限制，代码更健壮。</p><h3 id="composition-api" tabindex="-1">Composition API <a class="header-anchor" href="#composition-api" aria-hidden="true">#</a></h3><p>所有的API都是import引入的，没有用到的，打包时会被清理掉</p><p>代码复用方便，可以把一个功能的所有的methods，data都封装在一个独立函数里面</p><p>return语句，在实际项目中使用 <code>&lt;script setup&gt;</code> 特性可以清除</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 按需引入 reactive computed</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    reactive</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    computed</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Vue</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> App </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">setup</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            count</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">double</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">computed</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#A6ACCD;">add</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#A6ACCD;">double</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">Vue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createApp</span><span style="color:#A6ACCD;">(App)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">mount</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">#app</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><h3 id="新的组件" tabindex="-1">新的组件 <a class="header-anchor" href="#新的组件" aria-hidden="true">#</a></h3><p>Fragment：Vue3组件不再要求有一个唯一的根节点，清除了很多无用的占位div。</p><p>teleport：允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。</p><p>Suspense：异步组件，更方便开发有异步请求的组件。</p><h3 id="新一代工程化工具vite" tabindex="-1">新一代工程化工具Vite <a class="header-anchor" href="#新一代工程化工具vite" aria-hidden="true">#</a></h3><p>webpack：要把所有路由的依赖打包之后，才能开始调试 vite：调试环境下，不需要全部打包，根据首页依赖模块，再去按需加载。</p><h1 id="vue2升级到vue3" tabindex="-1">Vue2升级到Vue3 <a class="header-anchor" href="#vue2升级到vue3" aria-hidden="true">#</a></h1><h2 id="不兼容的写法" tabindex="-1">不兼容的写法 <a class="header-anchor" href="#不兼容的写法" aria-hidden="true">#</a></h2><ul><li>项目启动上的不同： <ul><li>Vue2：new Vue()</li><li>Vue3：createApp()，</li></ul></li><li>Vue3移除了<code>filter</code>、<code>$on</code>、<code>$off</code>、<code>$set</code>、<code>$delete</code>等 API</li><li>v-model用法更改</li><li>slot slot-scope 的更改</li><li>directive注册指令API更改</li></ul><h2 id="自动化工具的升级" tabindex="-1">自动化工具的升级 <a class="header-anchor" href="#自动化工具的升级" aria-hidden="true">#</a></h2><ul><li>@vue/compat</li><li>gogocode</li></ul>`,46),o=[p];function t(i,c,r,u,d,h){return e(),a("div",null,o)}const F=s(n,[["render",t]]);export{y as __pageData,F as default};
